# 애그리거트(Aggregate)
### Aggregate
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만드는 방법
- 상위 수준에서 전반적인 모델의 관계를 파악할 수 있게해준다.
- 한 aggregate의 구성요소는 함께 생성되고 함께 제거한다.
- 한 aggregate에 속한 객체는 다른 aggregate에 속하지 않는다.

### Aggregate root
- aggregate에 속한 객체가 일관된 상태를 유지하기 위해 root entity가 필요하다.
```
Order entity의 필드: 총 금액인 totalAmounts
OrderLine enttiy의 필드: 금액 price, 수량 quantity
```
- OrderLine의 개수가 바뀌면 Order에도 영향이 있다.
- 위의 예제에서는 Order가 root entity가 된다.

도메인 규칙과 일관성
- root entity에서 aggregate에 속하는 객체들의 일관성을 유지해야한다.
  
```java
public class Order{
  public void changeShippingInfo(){
  //도메인 규칙을 구현한 기능을 제공
    verifyNotYetShipped();
    setShippingInfo(newShippingInfo);
  }

  public void verifyNotYetShipped(){
    if(state != OrderState.PAYMENT_WAITING) throw new IllegalStateException("이미 출하지시 되었습니다.");
  }
}
```
- 배송이 시작되기 전까지만 배송정보를 바꿀수있는 로직이다.
- 위에서 이야기한 root aggregate인 Order를 통해 상태의 일관성을 유지해야한다.

```java
ShippingInfo shippingInfo = order.getShippingInfo();
shippingInfo.setAddress(newAddress);
```

- 위 예제처럼 외부에서 aggregate에 속한 객체를 직접 변경하게 된다면?????
- 일관성을 깨는 원인이 된다.
- 위처럼 일관성을 깨지않고 불필요한 중복을 제거하기 위해서는 두가지 원칙을 중요하게 생각하자

```
1. 단순히 필드를 변경하는 setter를 public으로 만들지 않는다.
```
- setter의 경우 domain의 의도나 의미를 표현하지 못하고 domain의 로직을 application, presentation layer로 분산시킨다.
- public setter를 이용하지 않게되면 changePassword, changeShippingInfo와 같은 의미가 더 잘 드러나는 이름을 사용하는 빈도가 높아진다.

```
2. value type의 객체는 불변(immutable)으로 구현한다.
```

```java
ShippingInfo shippingInfo = order.getShippingInfo();
shippingInfo.setAddress(newAddress);

ShippingInfo가 불변 value라면? 위 코드는 컴파일 에러 발생 !
```

최종적으로 root aggregate를 통해서만 내부상태가 변경되도록 한다.

```java
public class Order{
  private ShippingInfo shippingInfo;

  public void changeShippingInfo(ShippingInfo newShippingInfo){
  //도메인 규칙을 구현한 기능을 제공
    verifyNotYetShipped();
    setShippingInfo(newShippingInfo);
  }

  public void verifyNotYetShipped(){
    if(state != OrderState.PAYMENT_WAITING) throw new IllegalStateException("이미 출하지시 되었습니다.");
  }

  //값의 일부를 수정할 수 없는 불변객체로 만들어
  //새로운 value객체로 값을 변경한다.
  private void setShippingInfo(ShippingInfo newShippingInfo){
    this.shippingInfo = newShippingInfo;
  }
}
```

Aggregate root의 기능 구현
- aggregate root는 aggregate 내부의 다른 객체를 조합해 기능을 완성한다.

```java
public class Order{
  private Money totalAmounts;
  private List<OrderLine> orderLines;

  private void calculateTotalAmounts(){
    int sum = orderLines.stream().mapToInt(ol -> ol.getPrice() * ol.getQuantity()).sum();
    this.totalAmounts = new Money(sum);
  }

  //문제가 있는 코드
  public void changeOrderLines(List<OrderLine> newOrderLines){
    orderLines.changeOrderLines(newOrderlines);
    this.totalAmounts = orderLines.getTotalAmounts();
  }
}
```

- 위 코드에서 OrderLine의 changeOrderLines의 접근지시자도 public이다.
- 외부에서 상태를 바꿀 수 있다는 말인데, 이렇게되면 root aggregate인 Order 뿐아니라 어느곳에서도 OrderLine의 상태를 바꿀 수 있다.
- OrderLine의 목록을 바꿀 수 없도록 불변으로 구현하거나, protected로 접근지시자를 변경해 패키지 범위를 한정해 구현하자.

트랜잭션 범위
- 트랜잭션의 범위는 작을수록 좋다. 동시에 처리하는 처리량이 많아질수록 lock의 수도 많아져 성능에 영향이 있기때문
- 한 트랜잭션에서는 한 aggregate만 수정해야 한다.
- 즉, aggregate에서 다른 aggregate를 수정하면 안된다.
 
```java
public class Order{
  private Orderer orderer;

  public void shipTo(ShippingInfo newShippingInfo, boolean useNewShippingAddrAsMemberAddr){
    verifyNotYetShipped();
    setShippingInfo(newShippingInfo);

    //다른 aggregate member의 상태를 바꾸면 안됨!!!!!!!
    if(useNewShippingAddrAsMemberAddr){
      orderer.getMember().changeAddress(newShippingInfo.getAddress());
    }
  }
}
```

- aggregate의 책임범위를 넘어 다른 aggregate의 상태를 변경하게 되면, 결합도가 증가한다.
- 이 방법보다는 application layer에서 두 aggregate를 수정하도록 구현하는편이 낫다.


```java
public class ChangeOrderService{
  @Transactional
  public void changeShippingInfo(OrderId id, ShippingInfo newShippingInfo, boolean useNewShippingAddrAsMemberAddr){
    Order order = orderRepository.findById(id);
    setShippingInfo(newShippingInfo);

    if(useNewShippingAddrAsMemberAddr){
      Member member = memberRepository.findMember(order.getOrderer());
      member.changeAddress(newShippingInfo.getAddress());
    }
  }
}
```

- 두 개 이상의 aggregate의 변경이 필요하다면, application layer에서 각 aggregate의 상태를 변경하는것이 좋다.

### Repository & Aggregate
- 객체의 영속성을 표현하는 repository는 aggregate 단위로 존재한다.
- 예를들어, Order와 OrderLine이 각각 별도의 DB 테이블에 저장한다고해서 각각의 repository를 만들지 않는다.
- Order가 root고 OrderLine이 root에 속하는 구성요소이므로 Order를 위한 repository만 존재한다.
