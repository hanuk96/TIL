# Repository와 모델 구현
#### JPA를 이용한 repository 구현
repository 모듈의 위치는 infraStructure 위치한다.
```
domain layer                         |  infraStructure layer
Model - ModelRepository(interface)   -  JpaModelRepository(concrete class)
```
- 위 처럼 concrete class를 infrastructure 위치에 두어서 infrastructure에 대한 의존을 낮춰야 한다.

repository 기본 기능 구현
- 기본 기능은 두가지이다
  - ID로 aggregate 조회하기
  - aggregate 저장하기
- 인터페이스는 aggregate root를 기준으로 작성한다.
- ex) Order(root entity), OrderLine, Orderer, ShippingInfo가 있다면 Order를 기준으로 repository 인터페이스를 작성한다.
- 조회하는 기능의 이름은 보통 "findBy프로퍼티명" 으로 작성한다.
- 삭제의 경우 요구사항이 있더라도 실제도 데이터를 삭제하는 경우는 많지 않다. 보통은 flag를 두어 화면에 보여줄 대상인지를 체크한다.

spirng data JPA를 이용한 repository 구현
- JPA reopository interface를 정의하면 spring에서 concrete class를 구현해준다.
- OrderNo타입을 식별자로하는 Order entity이다.
```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;
}
```
- OrderRepsitory는 다음과 같이 구현한다.
```java
public interface OrderRepository extends Repository<Order, OrderNo> {
    Optional<Order> findById(OrderNo id);
    void save(Order order);
}
```
### mapping 구현
- aggregate root는 entity이므로 @Entity로 mapping한다.
- 한 테이블안에 value와 entity가 같이있다면
  - value는 @Embeddable로 mapping 설정한다.
  - value type의 property는 @Embeded로 mapping 설정한다.
- 주문을 예로들어 볼때, Root Entity는 Order이고 하위에 속하는 Orderer, ShippingInfo는 value이다.
- Root Entity는 @Entity로 mapping
- 하위 value인 Orderer는 @Embedded를 이용
```java
@Entity
@Table(name = "purchase_order")
@Access(AccessType.FIELD)
public class Order {
    @EmbeddedId
    private OrderNo number;

    @Embedded
    private Orderer orderer;
}
```
- Order에 속하는 Orderer는 value이므로 @Embeddable로 설정
- MemberId의 id라는 field를 Orderer에서는 orderer_id로 사용해야하기 때문에 AttributeOverrides설정
```java
@Embeddable
public class Orderer {

    //MemberId에 정의된 컬럼 이름을 변경하기 위해
    @AttributeOverrides(
            @AttributeOverride(name = "id", column = @Column(name = "orderer_id"))
    )
    private MemberId memberId;

    @Column(name = "orderer_name")
    private String name;
}

@Embeddable
public class MemberId implements Serializable {
    @Column(name = "member_id")
    private String id;
}
```

기본 생성자
- 불변타입의 value는 setter 메서드를 제공하지 않는다.
- 파라미터가 없는 기본 생성자 또한 필요가 없다는 말이다.
- 하지만, JPA에서는 @Entity와 @Embededable로 클래스를 매핑하려면 파라미터가 없는 기본 생성자가 필요하다.

```java
@Embeddable
public class Receiver {
    @Column(name = "receiver_name")
    private String name;
    @Column(name = "receiver_phone")
    private String phone;

    protected Receiver() {} //JPA 적용을 위해

    public Receiver(String name, String phone) {
        this.name = name;
        this.phone = phone;
    }

    public String getName() {
        return name;
    }

    public String getPhone() {
        return phone;
    }
}
```
- 위의 기본 생성자는 JPA provider가 객체를 생성할때만 사용한다.
- 다른 코드에서 사용하면 값이 올바르지 못한 객체를 만드므로, protected로 설정하였다.

필드 접근 방식 사용
- entity가 제 역할을 하기위해선, 외부에 setter를 사용하기보다 의도가 잘 드러나는 기능을 제공해야 한다.
```
주문 상태변경을 위해 setState()보다는 취소시 cancel()을 사용
배송지를 변경하기 위해 setShippingInfo() 보다는 changeShippingInfo()를 사용
```
- 객체가 제공할 기능을 중심으로 entity를 구현하려면
- @Access(AccessType.FIELD)로 선언하여 getter와 setter는 구현하지 말아야한다.
